<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git Upstreams &amp; Submodules</title>
      <link href="/2020/08/22/git-upstream-submodule/"/>
      <url>/2020/08/22/git-upstream-submodule/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Upstreams-amp-Submodules"><a href="#Git-Upstreams-amp-Submodules" class="headerlink" title="Git Upstreams &amp; Submodules"></a>Git Upstreams &amp; Submodules</h1><h2 id="Upstreams"><a href="#Upstreams" class="headerlink" title="Upstreams"></a>Upstreams</h2><p>Sometimes you may encounter such a situation. You want to fork some projects and stay updated to those projects, but in the meantime you want to do some personal modifications. However, you don’t want to send those personal changes back to those upstreams (e.g those changes contain your personal information) and you want to make your forked repositories <strong>private</strong> (but you can’t with forking). Now all you need is git upstreams.</p><p>To make things simply, let’s say there is one repository on github called <code>A</code>, the first thing you wanna do is create a new empty repository <code>B</code> in your github, record the <code>&lt;urlB&gt;</code> of your repo. Then clone repo <code>A</code> to your local machine as usual:</p><pre class=" language-sh"><code class="language-sh">$ git clone <urlA> repoName$ cd repoName</code></pre><p>Make the origin of this <code>repoName</code>  upstream:</p><pre class=" language-sh"><code class="language-sh">$ git remote rename origin upstream</code></pre><p>Use your <code>&lt;urlA&gt;</code> and add your <code>repoName</code> to this url:</p><pre class=" language-sh"><code class="language-sh">$ git remote add origin <urlB></code></pre><p>Then you can push changes back to your repo <code>B</code>:</p><pre class=" language-sh"><code class="language-sh">$ git push origin master</code></pre><p>Till now, you successfully make <code>A</code> as upstream and <code>B</code> as the origin. Next time you want to update your <code>B</code> to <code>A</code>, all you need to do is:</p><pre class=" language-sh"><code class="language-sh">$ git pull upstream master && git push origin master</code></pre><p>Deal with those conflicts (if any) and then your private repo <code>B</code> is up to date with <code>A</code> but have your own modications as well.</p><h2 id="Submodules"><a href="#Submodules" class="headerlink" title="Submodules"></a>Submodules</h2><p>Now let’s you actually have a larger project <code>C</code> of which the <code>B</code> above is a part. In other words, you have two remote repos <code>C</code> and <code>B</code> since you want <code>B</code> updated with <code>A</code> as mentioned above. So <code>B</code> is in fact a submodule under <code>C</code>. This will cause some new issues, in fact. If you do nothing and try <code>git commit</code> the changes under <code>B</code> you will encounter warnings (<code> Changes not staged for commit</code>) and the changes are actually not commited. To solve this, you need to make <code>B</code> as submodule of <code>C</code> and pull/push two repos independently.</p><pre class=" language-sh"><code class="language-sh">$ cd /path/to/local/B$ git submodule add <urlB></code></pre><p>A common practice is when you finish your changes to <code>B</code> and <code>C</code>, go to the path of <code>B</code> and push those changes to repoB first:</p><pre class=" language-sh"><code class="language-sh">$ cd /path/to/local/B$ git add .$ git commit -m "commitMsg"$ git push origin master</code></pre><p>Then go back to the root of <code>C</code> and push changes:</p><pre class=" language-sh"><code class="language-sh">$ cd /path/to/local/C$ git add .$ git commit -m "commitMsg"$ git push origin master</code></pre><p>If you have multiple submodules and you want to push changes of everything at one time (normally I don’t do it this way), you may want to take a look <a href="https://www.vogella.com/tutorials/GitSubmodules/article.html">here</a>.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Version Control </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Does A* always return an optimal path?</title>
      <link href="/2020/08/15/admissibility-of-a/"/>
      <url>/2020/08/15/admissibility-of-a/</url>
      
        <content type="html"><![CDATA[<p>A* is a static path search algorithm which is used to find the shortest path from the source (S) to the goal (G) from a finite weighted graph. The math representation of A* is<br>$$f(n) = c(n) + h(n) $$</p><p>Some people may prefer using $g$ instead of $c$ to indicate the cost function. And the $h$ is a heuristic function. More information can be found from the original <a href="https://ai.stanford.edu/~nilsson/OnlinePubs-Nils/PublishedPapers/astar.pdf">paper</a>.</p><p>So let’s get back to the title, how about the admissibility of A*? Well, as we can guess, it actually relies on the heuristic function. Again, A* algorithm requires the $h$ should be a ‘good’ estimation or ‘admissible’. It means that it has to be no longer than the actual distance. But if $h$ has no meaning, e.g. 0, then it is BFS. An example in real life is letting $h$ be the Euclidean distance from the node to the goal in navigation. But what does it do with the optimality? Here’s a simplified math proof – proof by contradiction:</p><p>Say all previous states till $n$ have optimal cost values already. For the next state till $n’$ we would have $f(n’)=c(n’)+h(n’)$ which is minimum among states in OPEN list. But let’s assume $g(n’)$ itself is actually suboptimal,  that means there has to be at least one state $n’^*$ on an optimal path from S that is in OPEN,<br>$$c(n’^*) + h(n’^*) \geq  c(n’) + h(n’)  \qquad  (1)(\text{min})$$<br>meaning on the same time we have<br>$$c(n’^*) + \delta(n’^*, n’) &lt;  c(n’) \qquad  (2)(\text{assumption})$$<br>Rewrite (2) can give us<br>$$c(n’^*) + \delta(n’^*, n’) + h(n’) &lt;  c(n’) + h(n’) \qquad  (3) $$<br>As $h$ is admissible, we have<br>$$h(n’^*) +   \delta(n’^*, n’) &lt; h(n’) \qquad (4) (<br>\text{underestimate}) $$<br>So (3) would be<br>$$ c(n’^*) + h(n’^*) &lt; c(n’) + h(n’)$$<br>which is contradictory with (1), so $c(n)$ must be optimal.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
