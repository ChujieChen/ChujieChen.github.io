<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>A Matrix-Factorization-Based Recommendation System</title>
      <link href="/2020/11/22/a-matrix-factorization-based-recommendation-system/"/>
      <url>/2020/11/22/a-matrix-factorization-based-recommendation-system/</url>
      
        <content type="html"><![CDATA[<p>Personalized recommendation systems are popular business applications of machine learning.</p><h1 id="To-Be-Continued…"><a href="#To-Be-Continued…" class="headerlink" title="To Be Continued…"></a>To Be Continued…</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
            <tag> Machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set with Range Sums using Splay Tree</title>
      <link href="/2020/09/12/set-with-range-sums-using-splay-tree/"/>
      <url>/2020/09/12/set-with-range-sums-using-splay-tree/</url>
      
        <content type="html"><![CDATA[<p>A <a href="https://en.wikipedia.org/wiki/Splay_tree">splay tree</a> is a self-balancing binary search tree. It performs operations such as insertion, look-up and removal in O(log n) amortized time. The splay tree moves recently accessed elements to the root by splaying, so if the element is queried again it can be reached in O(1) time.</p><p>A fully-fledged splay tree involves such operations:</p><ul><li>Splay: moving the recently accessed nodes to the root through a series of rotations below based on different situation<ul><li>Zig</li><li>Zig-zig and Zag-zag</li><li>Zig-zag and Zag-zig</li></ul></li><li>Join: merging two subtrees</li><li>Split: splitting one tree into two subtrees</li><li>Insert: add an element</li><li>Delete: remove an element</li><li>Find: look up an element</li></ul><p>A good visualization can be found <a href="https://www.cs.usfca.edu/~galles/visualization/SplayTree.html">here</a>. More details about splay trees and above operations can be found on <a href="https://en.wikipedia.org/wiki/Splay_tree">Wikipedia</a>. Here I use an example called <strong>Set with range sums</strong> to show the application of splay trees.</p><h2 id="Set-with-Range-Sums"><a href="#Set-with-Range-Sums" class="headerlink" title="Set with Range Sums"></a>Set with Range Sums</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Implement a data structure that stores a set 𝑆 of integers with the following allowed operations:</p><ul><li><strong>add(𝑖)</strong> — add integer 𝑖 into the set <em>S</em> (if it was there already, the set doesn’t change).</li><li><strong>del(𝑖)</strong> — remove integer 𝑖 from the set 𝑆 (if there was no such element, nothing happens).</li><li><strong>find(𝑖)</strong> — check whether 𝑖 is in the set 𝑆 or not.</li><li><strong>sum(l, r)</strong> — output the sum of all elements 𝑣 in 𝑆 such that 𝑙 ≤𝑣 ≤𝑟.</li></ul><p>Initially the set 𝑆 is empty. The first line contains 𝑛 — the number of operations. The next 𝑛 lines contain operations. Each operation is one of the following:</p><ul><li>“+ i” — which means add some integer (not 𝑖, see below) to 𝑆,</li><li>“- i” — which means del some integer (not 𝑖, see below) from 𝑆,</li><li>“? i” — which means find some integer (not 𝑖, see below)in 𝑆,</li><li>“s l r” — which means compute the sum of all elements of 𝑆 within some range of values (not from 𝑙 to 𝑟, see below).</li></ul><p>To avoid integer overflow, we denote M = 1 000 000 001 and let x be the result of the last <strong>sum</strong> operation, or just 0 if there were no <strong>sum</strong> operations before.</p><ul><li>“+ i” means <strong>add</strong>((𝑖 + 𝑥) mod 𝑀),  </li><li>“- i” means <strong>del</strong>((𝑖 + 𝑥) mod 𝑀),  </li><li>“? i” means <strong>find</strong>((𝑖 + 𝑥) mod 𝑀),  </li><li>“s l r” means <strong>sum</strong>((𝑙+𝑥) mod 𝑀, (𝑟 + 𝑥) mod 𝑀).</li></ul><p>Constraints. 1 ≤ n ≤ 100 000; 0 ≤ i ≤ 10^9.</p><hr><p>This is typical problem that needs a splay tree if you care about the efficiency, as we can use the <strong>Split</strong> to get the range sum and <strong>Join</strong> two subtrees back to restore the structure.</p><h3 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h3><p>The idea is each <strong>Vertex</strong> (TreeNode) has a <strong>key</strong> representing an integer, a <strong>sum</strong> recording the sum of all the keys in the subtree, a <strong>left</strong> pointing to its left child vertex, a <strong>right</strong> pointing to its right child vertex, and a <strong>parent</strong> pointing to its parent vertex. Note that the <strong>sum</strong> is not static, but will constantly change as the splay tree changes.</p><p>With this design, <strong>add</strong> would just be Insert a vertex; <strong>del</strong> is the same as Delete; <strong>find</strong> equals Find. How about <strong>sum(l, r)</strong>? Well, if we <em>split</em> the splay tree into three subtrees: <strong><em>I</em></strong> (nodes having keys smaller than <strong>l</strong>), <strong><em>J</em></strong> (keys are greater than <strong>l</strong> but smaller than <strong>r</strong>), and <strong><em>K</em></strong> (keys are greater than <strong>r</strong>). Obviously, the sum we want is the sum stored in the root of the middle subtree <strong><em>J</em></strong>. Once we get the sum we need, we just need to merge three parts back. All operations of the splay tree run in $O(log n)$ time on average, so this is a very effective way to solve the problem.</p><h2 id="Let’s-Code"><a href="#Let’s-Code" class="headerlink" title="Let’s Code!"></a>Let’s Code!</h2><h3 id="Skeleton"><a href="#Skeleton" class="headerlink" title="Skeleton"></a>Skeleton</h3><p>First, let me present the skeleton of the java class that handles i/o.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import java.io.*;import java.util.*;public class SetRangeSum {    BufferedReader br;    PrintWriter out;    StringTokenizer st;    boolean eof;    public static final int MODULO = 1000000001;    void solve() throws IOException {        int n = nextInt();        int last_sum_result = 0;        for (int i = 0; i &lt; n; i++) {            char type = nextChar();            switch (type) {                case '+':                    {                        int x = nextInt();                        insert((x + last_sum_result) % MODULO);                    }                    break;                case '-':                    {                        int x = nextInt();                        erase((x + last_sum_result) % MODULO);                    }                    break;                case '?':                    {                        int x = nextInt();                        out.println(find((x + last_sum_result) % MODULO) ? "Found" : "Not found");                    }                    break;                case 's':                    {                        int l = nextInt();                        int r = nextInt();                        long res = sum((l + last_sum_result) % MODULO, (r + last_sum_result) % MODULO);                        out.println(res);                        last_sum_result = (int)(res % MODULO);                    }            }        }    }    SetRangeSum() throws IOException {        br = new BufferedReader(new InputStreamReader(System.in));        out = new PrintWriter(System.out);        solve();        out.close();    }    public static void main(String[] args) throws IOException {        new SetRangeSum();    }    String nextToken() {        while (st == null || !st.hasMoreTokens()) {            try {                st = new StringTokenizer(br.readLine());            } catch (Exception e) {                eof = true;                return null;            }        }        return st.nextToken();    }    int nextInt() throws IOException {        return Integer.parseInt(nextToken());    }    char nextChar() throws IOException {        return nextToken().charAt(0);    }}</code></pre><p>Clearly, we need to define the Vertex as the TreeNode in the splay tree. A vertex is defined to be able to hold a value <code>key</code>, the sum below the present node <code>sum</code>, <code>left</code> / <code>right</code> child node, and its <code>parent</code> node.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">// Splay tree implementation// Vertex of a splay treeclass Vertex {    int key;    // Sum of all the keys in the subtree - remember to update    // it after each operation that changes the tree.    long sum;    Vertex left;    Vertex right;    Vertex parent;    Vertex(int key, long sum, Vertex left, Vertex right, Vertex parent) {        this.key = key;        this.sum = sum;        this.left = left;        this.right = right;        this.parent = parent;    }}Vertex root = null;</code></pre><h3 id="Basic-operations"><a href="#Basic-operations" class="headerlink" title="Basic operations"></a>Basic operations</h3><p>Then as described above, we need basic operations like: Splay, Join, Split, Insert, Delete,  and Find. Let’s have the Splay as <code>splay</code> like so. Again, the <code>splay</code> moves the node through a series of rotations (<code>smallRotation / bigRotation</code>) that change the structure of the tree, and thus, the <code>vertex.sum</code> changes accordingly via calling <code>update</code>.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">// Makes splay of the given vertex and returns the new root.Vertex splay(Vertex v) {    if (v == null) return null;    while (v.parent != null) {        if (v.parent.parent == null) {            smallRotation(v);            break;        }        bigRotation(v);    }    return v;}void smallRotation(Vertex v) {    Vertex parent = v.parent;    if (parent == null) {        return;    }    Vertex grandparent = v.parent.parent;    if (parent.left == v) {        Vertex m = v.right;        v.right = parent;        parent.left = m;    } else {        Vertex m = v.left;        v.left = parent;        parent.right = m;    }    update(parent);    update(v);    v.parent = grandparent;    if (grandparent != null) {        if (grandparent.left == parent) {            grandparent.left = v;        } else {            grandparent.right = v;        }    }}void bigRotation(Vertex v) {    if (v.parent.left == v &amp;&amp; v.parent.parent.left == v.parent) {        // Zig-zig        smallRotation(v.parent);        smallRotation(v);    } else if (v.parent.right == v &amp;&amp; v.parent.parent.right == v.parent) {        // Zig-zig        smallRotation(v.parent);        smallRotation(v);    } else {        // Zig-zag        smallRotation(v);        smallRotation(v);    }}void update(Vertex v) {    if (v == null) return;    v.sum = v.key + (v.left != null ? v.left.sum : 0) + (v.right != null ? v.right.sum : 0);    if (v.left != null) {        v.left.parent = v;    }    if (v.right != null) {        v.right.parent = v;    }}</code></pre><p>We could also have <code>Join</code> as <code>merge</code> define below. Here we always choose the right root as the new root of the merged tree.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">Vertex merge(Vertex left, Vertex right) {    if (left == null) return right;    if (right == null) return left;    while (right.left != null) {        right = right.left;    }    right = splay(right);    right.left = left;    update(right);    return right;}</code></pre><p>Similarly, we can have <code>Split</code> as <code>split</code>. The <code>find</code> will be given later. At this stage we only need to know the <code>find</code> will give us two vertices given the <code>root</code> of the tree and the queried <code>key</code>: the result node and the new root (remember we always move the recently accessed node to the root). The <code>split</code> here would divide the tree into two trees and return two vertices representing two new roots of two divided trees.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">VertexPair split(Vertex root, int key) {    VertexPair result = new VertexPair();    VertexPair findAndRoot = find(root, key);    root = findAndRoot.right;    result.right = findAndRoot.left;    if (result.right == null) {        result.left = root;        return result;    }    result.right = splay(result.right);    result.left = result.right.left;    result.right.left = null;    if (result.left != null) {        result.left.parent = null;    }    update(result.left);    update(result.right);    return result;}class VertexPair {    Vertex left;    Vertex right;    VertexPair() {}    VertexPair(Vertex left, Vertex right) {        this.left = left;        this.right = right;    }}</code></pre><p>We then have <code>Insert</code> implemented as <code>insert</code>. We utilize <code>split</code> to disconnect the tree at the edge where the node <code>x</code> should be added, and <code>merge</code> the <code>x</code> with left subtree and right subtree.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">void insert(int x) {    // System.out.println("Inserting "+x);    Vertex left = null;    Vertex right = null;    Vertex new_vertex = null;    VertexPair leftRight = split(root, x);    left = leftRight.left;    right = leftRight.right;    if (right == null || right.key != x) {        new_vertex = new Vertex(x, x, null, null, null);    }    root = merge(merge(left, new_vertex), right);}</code></pre><p>We can also have <code>Delete</code> as <code>erase</code>: we use <code>split</code> to break the connection(s) between the targeting node <code>x</code> and the splay tree. Then we merge the rest back together.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">void erase(int x) {    // use split and merge    VertexPair leftMiddle = split(root, x);    Vertex left = leftMiddle.left;    Vertex middle = leftMiddle.right;    VertexPair middleRight = split(middle, x + 1);    middle = middleRight.left;    Vertex right = middleRight.right;    if (middle == null || middle.key != x) {        root = merge(merge(left, middle), right);    } else {        middle = null;        root = merge(left, right);    }}</code></pre><p>Lastly we have out <code>find</code> described previously.</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">// Searches for the given key in the tree with the given root// and calls splay for the deepest visited node after that.// Returns pair of the result and the new root.// If found, result is a pointer to the node with the given key.// Otherwise, result is a pointer to the node with the smallest// bigger key (next value in the order).// If the key is bigger than all keys in the tree,// then result is null.VertexPair find(Vertex root, int key) {    Vertex v = root;    Vertex last = root;    Vertex next = null;    while (v != null) {        if (v.key &gt;= key &amp;&amp; (next == null || v.key &lt; next.key)) {            next = v;        }        last = v;        if (v.key == key) {            break;        }        if (v.key &lt; key) {            v = v.right;        } else {            v = v.left;        }    }    root = splay(last);    return new VertexPair(next, root);}boolean find(int x) {    // By looking into find(Vertex, int) if found,    // the right of the returned VertexPair is the node    // the left is the smallest bigger node    /* Does this work? */    //     VertexPair leftRight = find(root, x);    //     if(leftRight.right != null &amp;&amp; leftRight.right.key == x) {    //         return true;    //     }    //     return false;    Vertex left = null;    Vertex right = null;    VertexPair leftRight = split(root, x);    left = leftRight.left;    right = leftRight.right;    if (right == null || right.key != x) {        root = merge(left, right);        return false;    } else {        root = merge(left, right);        return true;    }}</code></pre><p>Finally, we can use the splay tree and calculate the range sum via <code>sum</code>: As described above, we split the tree into three parts among which the middle part ranges from <code>from</code> to <code>to</code>, then we can get the range sum easily. After the query, we just need to merge those three parts back to restore the splay tree.</p><h3 id="Range-sum"><a href="#Range-sum" class="headerlink" title="Range sum"></a>Range sum</h3><pre class="line-numbers language-js" data-language="js"><code class="language-js">long sum(int from, int to) {    //        System.out.println("From "+from + " to " + to);    VertexPair leftMiddle = split(root, from);    Vertex left = leftMiddle.left;    Vertex middle = leftMiddle.right;    VertexPair middleRight = split(middle, to + 1);    middle = middleRight.left;    Vertex right = middleRight.right;    long ans = 0;    // Complete the implementation of sum    if (middle != null)        ans = middle.sum;    middle = merge(middle, right);    root = merge(left, middle);    return ans;}</code></pre><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p>The full implementation can be found <a href="https://github.com/ChujieChen/Data_Structures/blob/master/src/week4/SetRangeSum.java">here</a>. Feel free to test it with some examples below.</p><p><em>Sample 1</em><br>Input:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">15? 1+ 1? 1+ 2s 1 2+ 1000000000? 1000000000- 1000000000? 1000000000s 999999999 1000000000 -2? 2- 0+ 9s 0 9</code></pre><p>Output:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">Not foundFound3FoundNot found1Not found10</code></pre><p>Explanation:<br>For the first 5 queries, 𝑥 = 0. For the next 5 queries, 𝑥 = 3. For the next 5 queries, 𝑥 = 1. The actual list of operations is:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">find(1)add(1)find(1)add(2)sum(1, 2) → 3add(2)find(2) → Founddel(2)find(2) → Not foundsum(1, 2) → 1del(3)find(3) → Not founddel(1)add(10)sum(1, 10) → 10</code></pre><p><em>Sample 2</em><br>Input:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">5? 0+ 0? 0- 0? 0</code></pre><p>Output:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">Not foundFoundNot found</code></pre><p><em>Sample 3</em><br>Input:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">5+ 491572259? 491572259? 899375874s 310971296 877523306+ 352411209</code></pre><p>Output:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">FoundNot found491572259</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Glance at State Hooks in React</title>
      <link href="/2020/09/01/a-glance-at-state-hooks-in-react/"/>
      <url>/2020/09/01/a-glance-at-state-hooks-in-react/</url>
      
        <content type="html"><![CDATA[<h1 id="A-Glance-at-State-Hooks-in-React"><a href="#A-Glance-at-State-Hooks-in-React" class="headerlink" title="A Glance at State Hooks in React"></a>A Glance at State Hooks in React</h1><h2 id="Hooks-vs-Class-Components"><a href="#Hooks-vs-Class-Components" class="headerlink" title="Hooks vs. Class Components"></a>Hooks vs. Class Components</h2><p>Hooks make your react code look simpler. Take a counter program as an example.<br>Using class components:</p><pre class="line-numbers language-javascript" data-language="javascript" data-start="1" data-line="" data-line-offset="0"><code class="language-javascript">import React from "react";class ClassComponent extends React.Component {  constructor() {    super();    this.state = {      count: 0    };    this.increase = this.increase.bind(this);  }  increase() {    this.setState({ count: this.state.count + 1 });  }  render() {    return (      &lt;div&gt;        &lt;h1&gt;{this.state.count}&lt;/h1&gt;        &lt;button onClick={this.increase}&gt;+&lt;/button&gt;      &lt;/div&gt;    );  }}export default ClassComponent;</code></pre><p>But with hooks, one can import <code>useState</code> first and instead of creating a class.</p><pre class="line-numbers language-javascript" data-language="javascript" data-start="1" data-line="" data-line-offset="0"><code class="language-javascript">import React, { useState } from "react";function FunctionalComponent() {  const [count, setCount] = useState(0);  function increase() {    setCount(count + 1);  }  return (    &lt;div&gt;      &lt;h1&gt;{count}&lt;/h1&gt;      &lt;button onClick={increase}&gt;+&lt;/button&gt;    &lt;/div&gt;  );}export default FunctionalComponent;</code></pre><p>Hooks provide a more direct API to the React concepts like props, state, context, refs, and lifecycle. There are a variety of hooks available: 1. that can store data (e.g. <code>useState</code>,<code>useReducer</code>) and connect data with lifecycle; 2. that can provide some memory functionality (e.g. <code>useMemo</code>,<code>useCallback</code>) so we can store some values in the previous execution; 3. that can provide more control (e.g. <code>useEffect</code>,<code>useRef</code>, <code>useContext</code>) so we have a extensive access and control inside React.</p><h2 id="Example-Clock-with-State-Hooks"><a href="#Example-Clock-with-State-Hooks" class="headerlink" title="Example: Clock with State Hooks"></a>Example: Clock with State Hooks</h2><p>Here is an example using state hooks to update a clock every one second. with <code>setInterval(updateTime, 1000);</code>. The <code>const [time, setTime]</code> line follows the JavaScript syntax called array destructuring. One can think the <code>time</code> as <code>this.state.time</code> and <code>setTime</code> as <code>this.setState</code> in a class.</p><pre class="line-numbers language-javascript" data-language="javascript" data-start="1" data-line="" data-line-offset="0"><code class="language-javascript">import React, { useState } from "react";function App() {  setInterval(updateTime, 1000);  const [time, setTime] = useState(new Date().toLocaleTimeString("en-GB"));  function updateTime() {    const newTime = new Date().toLocaleTimeString("en-GB");    setTime(newTime);  }  return (    &lt;div className="container"&gt;      &lt;h1&gt;{time}&lt;/h1&gt;      &lt;button onClick={updateTime}&gt;Get Time&lt;/button&gt;    &lt;/div&gt;  );}export default App;</code></pre><h2 id="Example-To-Do-List-using-State-Hooks-and-Props"><a href="#Example-To-Do-List-using-State-Hooks-and-Props" class="headerlink" title="Example: To-Do List using State Hooks and Props"></a>Example: To-Do List using State Hooks and Props</h2><p>Below is a to-do list (source code: <a href="https://codesandbox.io/s/to-do-list-using-state-hooks-and-props-4d0me?file=/src/components/App.jsx">codesandbox</a>). The <code>App</code> component (shown below) contains two components - <code>InputArea</code> and <code>ToDoItem</code>. <code>items</code> is the array used to store items showing on the screen, <code>setItems</code> is the function we use to update the <code>items</code>. Since we just want to add / delete an item from <code>items</code> but not to create a new array every time, we can work on the previous state with React hook and use spread operator in JS ES6 to extend the array or use <code>filter</code> method to delete the item that is clicked.</p><pre class="line-numbers language-javascript" data-language="javascript" data-start="1" data-line="" data-line-offset="0"><code class="language-javascript">import React, { useState } from "react";import ToDoItem from "./ToDoItem";import InputArea from "./InputArea";function App() {  const [items, setItems] = useState([]);  function addItem(inputText) {    setItems((prevItems) =&gt; {      return [...prevItems, inputText];    });  }  function deleteItem(id) {    setItems((prevItems) =&gt; {      return prevItems.filter((item, index) =&gt; {        return index !== id;      });    });  }  return (    &lt;div className="container"&gt;      &lt;div className="heading"&gt;        &lt;h1&gt;To-Do List&lt;/h1&gt;      &lt;/div&gt;      &lt;InputArea onAdd={addItem} /&gt;      &lt;div&gt;        &lt;ul&gt;          {items.map((todoItem, index) =&gt; (            &lt;ToDoItem              key={index}              id={index}              text={todoItem}              onChecked={deleteItem}            /&gt;          ))}        &lt;/ul&gt;      &lt;/div&gt;    &lt;/div&gt;  );}export default App;</code></pre><p><code>InputArea</code> (shown below) contains <code>inputText</code> which stores the text typed in the input. It is updated by the <code>onChange</code>‘s <code>handleChange</code> in the <code>input</code> element. What interesting is the <code>onClick</code> inside the <code>button</code> element. It allows us to add what we just typed into the array defined in <code>App.jsx</code>. If we take a closer look, the <code>onAdd</code> which carries <code>addItem</code> is passed from <code>App.jsx</code> (Yes! We can pass functions as props). Since we don’t want the <code>addItem</code> executed immediately when the page gets rendered, we write line 14-16 using the arrow operator.</p><pre class="line-numbers language-javascript" data-language="javascript" data-start="1" data-line="" data-line-offset="0"><code class="language-javascript">import React, { useState } from "react";function InputArea(props) {  const [inputText, setInputText] = useState("");  function handleChange(event) {    const newValue = event.target.value;    setInputText(newValue);  }  return (    &lt;div className="form"&gt;      &lt;input onChange={handleChange} type="text" value={inputText} /&gt;      &lt;button        onClick={() =&gt; {          props.onAdd(inputText);          setInputText("");        }}      &gt;        &lt;span&gt;Add&lt;/span&gt;      &lt;/button&gt;    &lt;/div&gt;  );}export default InputArea;</code></pre><p> Similarly, in <code>ToDoItem.jsx</code> (shown below) the <code>props.onChecked</code> was passed from <code>App.jsx</code> and it’s the function <code>deleteItem</code>. Since <code>props.onChecked</code> is called from <code>ToDoItem.jsx</code>, we also need to pass the <code>id</code> from <code>App.jsx</code> to <code>ToDoItem.jsx</code> using props so we can delete that item properly.</p><pre class="line-numbers language-javascript" data-language="javascript" data-start="1" data-line="" data-line-offset="0"><code class="language-javascript"> import React from "react";function ToDoItem(props) {  return (    &lt;div      onClick={() =&gt; {        props.onChecked(props.id);      }}    &gt;      &lt;li&gt;{props.text}&lt;/li&gt;    &lt;/div&gt;  );}export default ToDoItem;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Front End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React.js </tag>
            
            <tag> Web Development </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Upstreams &amp; Submodules</title>
      <link href="/2020/08/22/git-upstream-submodule/"/>
      <url>/2020/08/22/git-upstream-submodule/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Upstreams-amp-Submodules"><a href="#Git-Upstreams-amp-Submodules" class="headerlink" title="Git Upstreams &amp; Submodules"></a>Git Upstreams &amp; Submodules</h1><h2 id="Upstreams"><a href="#Upstreams" class="headerlink" title="Upstreams"></a>Upstreams</h2><p>Sometimes you may encounter such a situation. You want to fork some projects and stay updated to those projects, but in the meantime you want to do some personal modifications. However, you don’t want to send those personal changes back to those upstreams (e.g those changes contain your personal information) and you want to make your forked repositories <strong>private</strong> (but you can’t with forking). Now all you need is git upstreams.</p><p>To make things simply, let’s say there is one repository on github called <code>A</code>, the first thing you wanna do is create a new empty repository <code>B</code> in your github, record the <code>&lt;urlB&gt;</code> of your repo. Then clone repo <code>A</code> to your local machine as usual:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">$ git clone &lt;urlA&gt; repoName$ cd repoName</code></pre><p>Make the origin of this <code>repoName</code>  upstream:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">$ git remote rename origin upstream</code></pre><p>Use your <code>&lt;urlB&gt;</code> and add your <code>repoName</code> to this url:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">$ git remote add origin &lt;urlB&gt;</code></pre><p>Then you can push changes back to your repo <code>B</code>:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">$ git push origin master</code></pre><p>Till now, you successfully make <code>A</code> as upstream and <code>B</code> as the origin. Next time you want to update your <code>B</code> to <code>A</code>, all you need to do is:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">$ git pull upstream master &amp;&amp; git push origin master</code></pre><p>Deal with those conflicts (if any) and then your private repo <code>B</code> is up to date with <code>A</code> but also have your own modifications as well.</p><h2 id="Submodules"><a href="#Submodules" class="headerlink" title="Submodules"></a>Submodules</h2><p>Now let’s say you actually have a larger project <code>C</code> of which the <code>B</code> above is a part. In other words, you have two remote repos <code>C</code> and <code>B</code> and you want <code>B</code> updated with <code>A</code> as mentioned above. So <code>B</code> is in fact a submodule under <code>C</code>. This will cause some new issues, in fact. If you do nothing and try <code>git commit</code> the changes of <code>B</code> under <code>C</code> you will encounter warnings (<code>Changes not staged for commit</code>) and the changes are actually not commited. To solve this, you need to make <code>B</code> as submodule of <code>C</code> and pull/push two repos independently.</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">$ cd /path/to/local/B$ git submodule add &lt;urlB&gt;</code></pre><p>A common practice is when you finish your changes to <code>B</code> and <code>C</code>, go to the path of <code>B</code> and push those changes to repoB first:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">$ cd /path/to/local/B$ git add .$ git commit -m "commitMsg"$ git push origin master</code></pre><p>Then go back to the root of <code>C</code> and push changes:</p><pre class="line-numbers language-clike" data-language="clike"><code class="language-clike">$ cd /path/to/local/C$ git add .$ git commit -m "commitMsg"$ git push origin master</code></pre><p>If you have multiple submodules and you want to push changes of everything at one time (normally I don’t do it this way), you may want to take a look <a href="https://www.vogella.com/tutorials/GitSubmodules/article.html">here</a>.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Tool </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Version control </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Does A* always return an optimal path?</title>
      <link href="/2020/08/15/admissibility-of-a/"/>
      <url>/2020/08/15/admissibility-of-a/</url>
      
        <content type="html"><![CDATA[<p>A* is a static path search algorithm which is used to find the shortest path from the source (S) to the goal (G) from a finite weighted graph. The math representation of A* is<br>$$f(n) = c(n) + h(n) $$</p><p>Some people may prefer using $g$ instead of $c$ to indicate the cost function. And the $h$ is a heuristic function. More information can be found from the original <a href="https://ai.stanford.edu/~nilsson/OnlinePubs-Nils/PublishedPapers/astar.pdf">paper</a>.</p><p>So let’s get back to the title, how about the admissibility of A*? Well, as we can guess, it actually relies on the heuristic function. Again, A* algorithm requires the $h$ should be a ‘good’ estimation or ‘admissible’. It means that it has to be no longer than the actual distance. But if $h$ has no meaning, e.g. 0, then it is BFS. An example in real life is letting $h$ be the Euclidean distance from the node to the goal in navigation. But what does it do with the optimality? Here’s a simplified math proof – proof by contradiction:</p><p>Say all previous states till $n$ have optimal cost values already. For the next state till $n’$ we would have $f(n’)=c(n’)+h(n’)$ which is minimum among states in OPEN list. But let’s assume $g(n’)$ itself is actually suboptimal,  that means there has to be at least one state $n’^*$ on an optimal path from S that is in OPEN,<br>$$c(n’^*) + h(n’^*) \geq  c(n’) + h(n’)  \qquad  (1)(\text{min})$$<br>meaning on the same time we have<br>$$c(n’^*) + \delta(n’^*, n’) &lt;  c(n’) \qquad  (2)(\text{assumption})$$<br>Rewrite (2) can give us<br>$$c(n’^*) + \delta(n’^*, n’) + h(n’) &lt;  c(n’) + h(n’) \qquad  (3) $$<br>As $h$ is admissible, we have<br>$$h(n’^*) +   \delta(n’^*, n’) &lt; h(n’) \qquad (4) (<br>\text{underestimate}) $$<br>So (3) would be<br>$$ c(n’^*) + h(n’^*) &lt; c(n’) + h(n’)$$<br>which is contradictory with (1), so $c(n)$ must be optimal.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
